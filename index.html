<!DOCTYPE html>
<html>
<head>
    <title>NOWMULTIMEDIA MXS-004 Studio Receiver</title>
    <!-- Google Cast Web Receiver SDK -->
    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <link rel="stylesheet" href="styles_v101.css">
    <style>
        body {
            background-color: transparent !important;
            overflow: hidden; /* Cast receiver shouldn't scroll */
        }
        
        /* Hide Cast Default Player */
        cast-media-player {
            display: none;
        }

        #mxs-studio-container {
            display: none; /* Hidden until state arrives */
            width: 100vw;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            background: linear-gradient(135deg, #1a1a1a 0%, #000 100%);
        }

        #splash {
            text-align: center;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #splash h1 {
            color: #FAD78E;
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(250, 215, 142, 0.5);
            font-family: 'Courier New', monospace;
        }
        #splash h2 {
            color: #008000;
            font-size: 1.5em;
            font-family: 'Courier New', monospace;
        }
        #status-text {
            color: #ccc;
            margin-top: 15px;
            font-size: 1.2em;
            font-family: 'Courier New', monospace;
        }

        /* Enforce Read-Only UI on Cast */
        .track * {
            pointer-events: none !important;
        }
        
        .debug-panel {
            position: absolute;
            top: 10px; right: 10px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #333;
            color: #0f0;
            padding: 10px;
            font-family: monospace;
            max-width: 400px;
            max-height: 200px;
            overflow: hidden;
            display: none; /* Change to block to debug */
        }
    </style>
</head>
<body>
    <cast-media-player></cast-media-player>

    <div id="splash">
        <h1>MXS-004 STUDIO</h1>
        <h2>HI-FI AUDIO PLAYBACK</h2>
        <div id="status-text">INITIALIZING RECEIVER...</div>
    </div>

    <!-- The mirror of the desktop App UI -->
    <div id="mxs-studio-container" class="container">
        <!-- Tracks are populated here by the state differ -->
        <div id="tracks-container"></div>
        
        <!-- Master Section -->
        <div id="master-section" class="master-bus">
            <h2 class="master-title">MASTER BUS</h2>
            
            <div class="meter-container master-meter-container">
                <canvas id="master-meter-canvas" width="60" height="200"></canvas>
            </div>
            
            <div class="master-controls">
                <div class="knob-container">
                    <div class="knob" id="master-vol-knob" style="transform: rotate(0deg);"></div>
                    <span class="knob-label">Vol: 0.0dB</span>
                </div>
            </div>
            <button id="master-play-btn" class="active">PLAYING</button>
            <div id="master-status" class="master-status-text">CAST RECEIVER ACTIVE</div>
        </div>
    </div>
    
    <div id="debug-log" class="debug-panel"></div>

    <!-- Include TrackView.js for DOM parity -->
    <script src="TrackView.js"></script>

    <script>
        const statusText = document.getElementById("status-text");
        const splash = document.getElementById("splash");
        const studioContainer = document.getElementById("mxs-studio-container");
        const tracksContainer = document.getElementById("tracks-container");
        const debugLog = document.getElementById("debug-log");
        
        function logMsg(msg) {
            console.log(msg);
            const line = document.createElement("div");
            line.textContent = `> ${msg}`;
            debugLog.appendChild(line);
            if(debugLog.children.length > 5) debugLog.removeChild(debugLog.firstChild);
        }

        logMsg("Initializing Cast Receiver...");

        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();
        
        const playbackConfig = new cast.framework.PlaybackConfig();
        playbackConfig.autoResumeDuration = 5;
        context.start({ playbackConfig: playbackConfig });

        playerManager.addEventListener(cast.framework.events.EventType.PLAYING, () => {
            statusText.textContent = "AUDIO STREAM ACTIVE";
            statusText.style.color = "#0f0";
            // Do not hide splash until we receive UI layout data
        });
        
        playerManager.addEventListener(cast.framework.events.EventType.ERROR, (event) => {
            statusText.textContent = "STREAM ERROR";
            statusText.style.color = "#f00";
        });

        // ==========================================================
        // UI REPLICATION ENGINE
        // ==========================================================

        // Generic custom message listener for Cast State Broadcaster
        context.addCustomMessageListener('urn:x-cast:com.nowmultimedia.hybrid', (event) => {
            try {
                const data = JSON.parse(event.data);
                
                // Native Stream Launch message
                const targetUrl = data.url || data.wsUrl;
                if (data.type === 'connect' && targetUrl && targetUrl.includes("audio_stream=")) {
                     const directUrl = decodeURIComponent(targetUrl.split("audio_stream=")[1].split("&")[0]);
                     logMsg("Connecting Audio Server: " + directUrl);
                     
                     let request = new cast.framework.messages.LoadRequestData();
                     let mediaInfo = new cast.framework.messages.MediaInformation();
                     mediaInfo.contentId = directUrl;
                     mediaInfo.contentType = 'audio/webm';
                     mediaInfo.streamType = cast.framework.messages.StreamType.LIVE;
                     request.media = mediaInfo;
                     
                     playerManager.load(request);
                     statusText.textContent = "CONNECTING TO AUDIO NODE...";
                }
                
                // Studio State Broadcaster Message
                if (data.type === 'STATE_UPDATE' || data.type === 'mxs_state') {
                    if(splash.style.display !== 'none') {
                        splash.style.display = 'none';
                        studioContainer.style.display = 'flex';
                    }
                    renderStudioState(data.state);
                }
                
            } catch (err) {
                logMsg("Parse Error: " + err.message);
            }
        });

        // Intercept native LOAD requests for legacy fallback
        playerManager.setMessageInterceptor(cast.framework.messages.MessageType.LOAD, request => {
            statusText.textContent = "CONNECTING NATIVE STREAM...";
            if (request.media) {
                request.media.streamType = cast.framework.messages.StreamType.LIVE;
                if (!request.media.contentType) request.media.contentType = 'audio/webm';
            }
            return request;
        });

        // ----------------------------------------------------
        // DOM Rendering Logic
        // Takes the JSON tree from the sender and builds/updates the CSS UI
        // ----------------------------------------------------
        function renderStudioState(state) {
            // Master updates
            if(state.master) {
                const volLabel = document.querySelector("#master-vol-knob + .knob-label");
                if(volLabel && state.master.volume !== undefined) {
                    volLabel.textContent = `Vol: ${state.master.volume.toFixed(1)}dB`;
                }
            }

            // Track updates
            if(!state.tracks || !Array.isArray(state.tracks)) return;
            
            state.tracks.forEach((trackState, index) => {
                let trackDiv = document.querySelector(`.track[data-id="${trackState.id}"]`);
                
                // Create if missing
                if (!trackDiv) {
                    const tv = new TrackView(trackState.id);
                    trackDiv = tv.buildElement();
                    trackDiv.dataset.id = trackState.id;
                    tracksContainer.appendChild(trackDiv);
                    trackDiv.__tv = tv; // Save ref for helper methods if needed
                }

                // Update Name
                const nameEl = trackDiv.querySelector(".file-name-display");
                if(nameEl && trackState.name) nameEl.textContent = trackState.name;

                // Update Colors
                if (trackState.color) {
                    trackDiv.style.borderColor = trackState.color;
                    const header = trackDiv.querySelector(".track-header");
                    if(header) header.style.background = `linear-gradient(to right, ${trackState.color}, rgba(0,0,0,0.8))`;
                }

                // Update Button States (Toggle colors)
                const playBtn = trackDiv.querySelector("button[data-action='play']");
                if(playBtn) {
                     if(trackState.isPlaying) {
                         playBtn.classList.add("active");
                         playBtn.style.color = "#0f0";
                         playBtn.style.borderColor = "#0f0";
                     } else {
                         playBtn.classList.remove("active");
                         playBtn.style.color = "";
                         playBtn.style.borderColor = "";
                     }
                }
                
                // Sliders/Knobs Text
                const volSlider = trackDiv.querySelector("input[data-param='vol']");
                const volVal = trackDiv.querySelector("span[data-value-for='vol']");
                if(volSlider && trackState.volume !== undefined) {
                    volSlider.value = trackState.volume;
                    if(volVal) volVal.textContent = trackState.volume.toFixed(1) + "dB";
                }
                
                const panSlider = trackDiv.querySelector("input[data-param='pan']");
                const panVal = trackDiv.querySelector("span[data-value-for='pan']");
                if(panSlider && trackState.pan !== undefined) {
                    panSlider.value = trackState.pan;
                    if(panVal) panVal.textContent = trackState.pan.toFixed(2);
                }
                
                // Track FX List
                const fxSlots = trackDiv.querySelectorAll(".fx-chain-slot label");
                if(fxSlots.length > 0 && trackState.effects) {
                    trackState.effects.forEach((eff, i) => {
                        if (i < fxSlots.length) {
                            fxSlots[i].textContent = eff ? eff.name.substring(0,3) : (i+1);
                            fxSlots[i].style.opacity = (eff && !eff.enabled) ? "0.5" : "1";
                            if(eff) {
                                fxSlots[i].style.background = "#0f0";
                                fxSlots[i].style.color = "#000";
                            } else {
                                fxSlots[i].style.background = "";
                                fxSlots[i].style.color = "";
                            }
                        }
                    });
                }
            });
            
            // Cleanup deleted tracks
            const currentIds = state.tracks.map(t => String(t.id));
            Array.from(tracksContainer.children).forEach(child => {
                 if(!currentIds.includes(child.dataset.id)) {
                     child.remove();
                 }
            });
        }
    </script>
</body>
</html>
